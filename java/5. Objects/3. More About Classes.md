# More About Classes

## Constructors

Let's look at our class from last time:

```java
public class Car
{
    String model;
    int age;
    String color;
    double speed;
}
```

```java
public static void main(String[] args)
{
    Car carObject = new Car();
    carObject.model = "Magic School Bus";
    carObject.age = 100;
    carObject.color = "Yellow";
    carObject.speed = 31415.9265;
}
```

You may notice that it's extremely tedious to set all of the variables. We would like to make it so that while we're creating the object with `new Car()`, we can just input our values there. We can do this with something known as constructors.

In our `Car.java`, let's define a constructor:

```java
public class Car
{
    String model;
    int age;
    String color;
    double speed;

    Car(String model, int age, String color, double speed)
    {
        this.model = model;
        this.age = age;
        this.color = color;
        this.speed = speed;
    }
}
```

```java
public static void main(String[] args)
{
    Car carObject = new Car("Magic School Bus", 100, "Yellow", 31415.9265);
}
```

In our constructor, we first define a set of input parameters. These are passed in when we create the object using `new Car(`. Then, back to our `Car` class, we have to define what we do with those. In this case, we assign our property, `this.model` to `model`. The reason why we have `this.model` and `model` is because there is a naming conflict between the constructor arguments and the properties. In this case, to differentiate the two, `this.model` refers to the property and `model` refers to the input parameter. Normally, we would want to make sure the names do not conlict, which would eliminate the need for the `this.`. However, in this case we did not, so we used `this.`.

## Package

When we're making a project with 100s of classes, we're going to have 100s of files. As a result, we always want to be able to organize these files within folders. Within Java, these folders are called `packages`. Whenever we put a file in a folder that is not the root folder, we have to put at the top `package foldername`. For instance, if `Car.java` were in the folder `automobiles`, we would put:

```java
package automobiles;

public class Car
{

}
```

If it were in the folder `automobiles/cars`, we would put:

```java
package automobiles.cars;

public class Car
{

}
```

## Import

If we have two classes, and they aren't in the same folder, then we have to do something called an `import` statement. For instance, say we have `automobiles/Cars.java` and `Main.java`. We would have to `import` the `Cars.java` file.

```java
package automobiles;

public class Car
{

}
```

```java
import automobiles.Car;

public class Main
{
    public static void main(String[] args)
    {
        System.out.println("Imported Cars");
    }
}
```

## Access Modifiers

When we have a project with multiple files, there are times in which we want to limit the amount of access classes have to each other. For instance, if we had a security program, we wouldn't want just any file to access the variables and methods of another file. Additionally, to make code cleaner and more maintainable, there are various reasons why we would want to limit access to only a few files.

Whenever we have a variable or a function, we can change its access modifier. For instance, if we change the access modifier of a variable, then we can change whether it is available to other files.

Here are the access modifiers:
- private: Only code in the same file can access this 
- (default): Only code in the same package/folder can access this
- public: Any code can access this

There is another one called `protected`, but we won't cover it. We will not need to use it, but you can research it yourself if you want.

Let's say we have a file named `Other.java`, `MainSame.java`, and `folder/MainOut`. `MainOut.java` will be inside of a separate folder than Other.java, while `MainSame.java` will be in the same folder as `Other.java`

```java
public class Other {
    private int number1;
    int number2;
    public int number3;

    private void print1() {
        System.out.println("Print 1");
    }
    void print2() {
        System.out.println("Print 2");
    }
    public void print3() {
        System.out.println("Print3 ");
    }
}
```

```java
public class MainSame {
    public static void main(String[] args) {
        Other o = new Other();
        System.out.println(o.number1); // This will not work, nothing outside of the class Other can access private
        System.out.println(o.number2); // This will work, since MainSame is in the same folder
        System.out.println(o.number3); // This will work, since anything can access public

        o.print1(); // This will not work, nothing outside of the class Other can access private
        o.print2(); // This will work, since MainSame is in the same folder
        o.print3(); // This will work, since anything can access public
    }
}
```

```java
package folder;

public class MainOut {
    public static void main(String[] args) {
        Other o = new Other();
        System.out.println(o.number1); // This will not work, nothing outside of the class Other can access private
        System.out.println(o.number2); // This will not work, since MainSame is not in the same folder
        System.out.println(o.number3); // This will work, since anything can access public

        o.print1(); // This will not work, nothing outside of the class Other can access private
        o.print2(); // This will not work, since MainSame is not in the same folder
        o.print3(); // This will work, since anything can access public
    }
}
```

## Constants

Before, we talked about how static variables are shared and do not require variables. As a result, when we have constants in programming, such as robot max speed, we normally make a file called `Constants.java`.

```java
public class Constants
{
    public static final double ROBOT_MAX_SPEED = 12.0;
}
```

In here, we put all of our constants in one place so that they can be easily found and adjusted if necessary. We can access it by calling `Constants.ROBOT_MAX_SPEED`.
